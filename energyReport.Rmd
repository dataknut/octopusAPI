---
title: "Smart meter energy use report: the new chez nous"
subtitle: "AKA testing the octopus API #rstats"
author: "Ben Anderson"
date: 'Last run at: `r Sys.time()`'
output:
  bookdown::html_document2:
    fig_caption: yes
    code_folding: hide
    number_sections: yes
    toc: yes
    toc_depth: 4
    toc_float: TRUE
  bookdown::pdf_document2:
    fig_caption: yes
    number_sections: yes
---

```{r setup, include=FALSE}
# options ----
knitr::opts_chunk$set(echo = TRUE)

# libraries ----

library(dkUtils) # find me at https://github.com/dataknut/dkUtils

rmdLibs <- c("data.table",
             "flextable",
             "ggplot2",
             "hms",
             "httr",
             "jsonlite",
             "lubridate",
             "plotly",
             "readxl",
             "skimr")
dkUtils::loadLibraries(rmdLibs)

# parameters ----
source("~/Dropbox/api/octopusAPI_key.R") # api params
# DO NOT PRINT THE KEY!

esoDataPath <- path.expand("~/Dropbox/data/UK_NGESO/genMix/")

rmdParams <- list() # params for this report
rmdParams$odPath <- "~/Dropbox/data/ba_octopus/" # where to save the json files
message("Test if rmdParams$odPath (", rmdParams$odPath, ") exists...")
dir.exists(path.expand(rmdParams$odPath))

# Functions ----
makeFlexTable <- function(df, cap = "caption", digits = 0){
  # makes a pretty flextable - see https://cran.r-project.org/web/packages/flextable/index.html
  ft <- flextable::flextable(df)
  ft <- colformat_double(ft, digits = digits)
  ft <- fontsize(ft, size = 9)
  ft <- fontsize(ft, size = 10, part = "header")
  ft <- set_caption(ft, caption = cap)
  return(flextable::autofit(ft))
}

makeDerivedVars <- function(dt){
  # takes a consumption data.table and adds frequently used derived vars
  dt[, dv_start := lubridate::as_datetime(interval_start)] # start of half-hour
  dt[, dv_hms := hms::as_hms(dv_start)]
  dt[, dv_date := lubridate::as_date(dv_start)]
  
  dt[, dv_peakPeriod := ifelse(dv_hms < as_hms("06:00:00"), "Early morning (00:00 - 06:00)", NA)]
  dt[, dv_peakPeriod := ifelse(dv_hms >= as_hms("06:00:00") & dv_hms < as_hms("08:30:00"), 
                               "Morning peak (06:00 - 08:30)", 
                               dv_peakPeriod)]
  dt[, dv_peakPeriod := ifelse(dv_hms >= as_hms("08:30:00") & dv_hms < as_hms("16:30:00"), 
                               "Day time (08:30 - 16:30", 
                               dv_peakPeriod)]
  dt[, dv_peakPeriod := ifelse(dv_hms >= as_hms("16:30:00") & dv_hms < as_hms("21:30:00"), 
                               "Evening peak (16:30 - 21:30)", 
                               dv_peakPeriod)]
  dt[, dv_peakPeriod := ifelse(dv_hms >= as_hms("21:30:00"), 
                               "Late evening (21:30 - 00:00)", 
                               dv_peakPeriod)]
  
  # MUST match labels above
  levels <- c("Early morning (00:00 - 06:00)", 
              "Morning peak (06:00 - 08:30)", 
              "Day time (08:30 - 16:30", 
              "Evening peak (16:30 - 21:30)", 
              "Late evening (21:30 - 00:00)") # set order nicely for plots & tables
  # check
  # dt[, dv_hour := lubridate::hour(dv_start)]
  #table(dt$dv_hour, dt$dv_peakPeriod)
  
  dt[, dv_peakPeriod := factor(dv_peakPeriod, levels)] # set order for plots etc
  
  dt[, dv_weekend := ifelse(lubridate::wday(dv_date, label = TRUE) == "Sat",
                            "Saturday",
                            "Weekday")]
  dt[, dv_weekend := ifelse(lubridate::wday(dv_date, label = TRUE) == "Sun",
                            "Sunday",
                            dv_weekend)]
  return(dt)
}
```

# Inspired by

https://www.guylipman.com/octopus/api_guide.html

and using

https://developer.octopus.energy/docs/api/#

# Code

More at: https://dataknut.github.io/octopusAPI/

Code at: https://github.com/dataknut/octopusAPI

# Data

This analysis uses:

* our smart meter data, downloaded via the Octopus API
* the NG-ESO half-hourly carbon intensity data

## Octopus smart meter data

See below

## NG-ESO half-hourly carbon intensity data

We save this locally, if it is older than 1 day we re-download.

```{r getNGESOelec}
# this needs to be more clever - only download dates we want from API?
esoF <- paste0(esoDataPath, "latest_df_fuel_ckan.csv")
# check for gzipped version (see below)
if(file.exists(paste0(esoF, ".gz"))){ 
  message("We already have a version saved to: ", paste0(esoF, ".gz"))
  message("Loading it...")
  ngeso_dt_orig <- data.table::fread(paste0(esoF, ".gz"))
} else {
  message("We don't already have a version, downloading and saving to: ", esoF)
  ngeso_dt_orig <- data.table::fread("https://data.nationalgrideso.com/backend/dataset/88313ae5-94e4-4ddc-a790-593554d8c6b9/resource/f93d1835-75bc-43e5-84ad-12472b180a98/download/df_fuel_ckan.csv")
  # nice dateTime
  ngeso_dt_orig[, dv_start := lubridate::as_datetime(DATETIME)]
  data.table::fwrite(ngeso_dt_orig, esoF) # save locally for future re-use
  dkUtils::gzipIt(esoF)
}

# if older than 1 day, reload
today <- lubridate::today()
lastNGESO <- as.Date(max(ngeso_dt_orig$dv_start))

if(today - lastNGESO > 1) {
  # old data, reload
  message("But the version we have dates from ", lastNGESO, " (",today - lastNGESO ," days ago), downloading latest...")
  ngeso_dt_orig <- data.table::fread("https://data.nationalgrideso.com/backend/dataset/88313ae5-94e4-4ddc-a790-593554d8c6b9/resource/f93d1835-75bc-43e5-84ad-12472b180a98/download/df_fuel_ckan.csv")
  # nice dateTime
  ngeso_dt_orig[, dv_start := lubridate::as_datetime(DATETIME)]
  data.table::fwrite(ngeso_dt_orig, esoF)
  dkUtils::gzipIt(esoF)
}

# we think renewable is wind + solar, low carbon includes nuclear

ngeso_dt_orig[, dv_date := lubridate::as_date(DATETIME)] # for filtering etc
ngeso_dt_orig[, dv_hms := hms::as_hms(DATETIME)] # for filtering etc

ngEsoCap <- paste0("Source: NG-ESO generation mix data ",
                   min(ngeso_dt_orig$dv_start), " - ",
                   max(ngeso_dt_orig$dv_start))

ngeso_dt_orig[, dv_peakPeriod := ifelse(dv_hms < as_hms("07:00:00"), "Early morning", NA)]
ngeso_dt_orig[, dv_peakPeriod := ifelse(dv_hms >= as_hms("07:00:00") & dv_hms < as_hms("09:00:00"), 
                                        "Morning peak", 
                                        dv_peakPeriod)]
ngeso_dt_orig[, dv_peakPeriod := ifelse(dv_hms >= as_hms("09:00:00") & dv_hms < as_hms("16:00:00"), 
                                        "Day time", 
                                        dv_peakPeriod)]
ngeso_dt_orig[, dv_peakPeriod := ifelse(dv_hms >= as_hms("16:00:00") & dv_hms < as_hms("20:00:00"), 
                                        "Evening peak", 
                                        dv_peakPeriod)]
ngeso_dt_orig[, dv_peakPeriod := ifelse(dv_hms >= as_hms("20:00:00"), 
                                        "Late evening", 
                                        dv_peakPeriod)]

levels <- c("Early morning", "Morning peak", "Day time", 
            "Evening peak", "Late evening") # set order nicely for plots & tables

ngeso_dt_orig[, dv_month := lubridate::floor_date(dv_date, unit = "months")]

ggplot2::ggplot(ngeso_dt_orig, aes(x = dv_month, 
                                   group = dv_month, 
                                   y = CARBON_INTENSITY)) +
  geom_boxplot() +
  labs(x = "Month",
       y = "Halfhourly carbon intensity (g CO2/MW)",
       caption = ngEsoCap)
```


# Testing public API access

Check the response code. This seems to generate errors (sometimes).

```{r getBasic}
# test
url <- "https://api.octopus.energy/v1/products"
message("Getting: ", url)
resp <- httr::GET(url)

message("Status code: ", resp$status_code)

df <- jsonlite::parse_json(resp, simplifyVector = TRUE)
makeFlexTable(head(df$results), cap = "Example products list (first 6 rows)")
```

# Our energy use

## Basic info

```{r getAuth}
url <- paste0("https://api.octopus.energy/v1/accounts/", apiParams$accountNo , "/")

resp <- httr::GET(url = url, authenticate(user = apiParams$key, password = ""))

df <- jsonlite::parse_json(resp, simplifyVector = TRUE)

props <- data.table::as.data.table(df$properties)
makeFlexTable(head(props[, .(town, county, 
                             electricity_meter_points,gas_meter_points)]), cap = "Properties linked to this account (non-disclosive data)")


```

List the electricity meters by MPAN. There should be two - import & export...

```{r listElec}
# this is a list of n mpans
length(props$electricity_meter_points)
message("n MPANS listed: ", length(df$properties$electricity_meter_points))
for(n in 1:length(df$properties$electricity_meter_points)){
  print(props$electricity_meter_points[n])
}

```

List the gas meters by MPRN. There should be only one...

```{r listGas}
length(df$properties$gas_meter_points)
message("n MPRNS listed: ", length(df$properties$gas_meter_points))
for(n in 1:length(df$properties$gas_meter_points)){
  print(df$properties$gas_meter_points[n])
}
```

## Electricity

### 'Consumption' (aka `use`)

See: https://www.guylipman.com/octopus/api_guide.html#s3

Start data extraction from 1st Jan 2022 as we had smart meter (re)installed in January.

> Check missing dates and adjust "&page_size=100000" if required

```{r getElecImport}
url <- paste0("https://api.octopus.energy/v1/electricity-meter-points/", 
              apiParams$elec_import_mpan , "/",
              "meters/",
              apiParams$elec_import_serial, "/",
              "consumption/",
              "?period_from=2022-01-01T00:00Z",
              "&page_size=100000") # make sure this is large enough!
# get data via httr ----
resp <- httr::GET(url = url, authenticate(user = apiParams$key, password = ""))
df <- jsonlite::parse_json(resp, simplifyVector = TRUE) # creates a df of which 'results' = the data

elecCons_dt <- data.table::as.data.table(df$results) # convert to dt

# derived variables ----
elecCons_dt <- makeDerivedVars(elecCons_dt)

maxTime <- max(elecCons_dt$dv_start)

hoursAgo <- now() - maxTime

# meter is SMETS2
elecCons_dt[, consumption_kWh := consumption] # for clarity - see https://developer.octopus.energy/docs/api/#list-consumption-for-a-meter

message("# Check start and end dates")
summary(elecCons_dt$dv_start)
```

The data used here is up to `r maxTime`, which is `r round(hoursAgo,1)` hours ago. In general the Octopus API seems to have data up to `midnight last night`.

### Half-hourly analysis

Figure \@ref(fig:plotElecImportHalfHourly) shows half-hourly electricity import ('consumption') for the current year. Spot the power cuts...

> To do: mark weekends somehow

```{r plotElecImportHalfHourly, fig.cap="Half hourly electricity import (current year)"}
ggplot2::ggplot(elecCons_dt, aes(x = dv_date, y = dv_hms, fill = consumption_kWh)) +
  geom_tile() +
  theme(legend.position = "bottom") +
  scale_fill_viridis_c(name = "Electricity import (kWh)") +
  labs(x = "Date",
       y = "Half-hour")
```

Repeat but with just the last 14 days of data - useful for checking recent appliance use and offspring effects. We do quite a lot of batch cooking on Sunday nights...

> Check this really is the last 14 days - there may be data errors

```{r plotElecImportHalfHourlyRecent, fig.cap="Half hourly electricity import (current year, last 14 days)"}
today <- lubridate::today()
plotDT <- elecCons_dt[dv_date >= max(dv_date) - 14]
p <- ggplot2::ggplot(plotDT, aes(x = dv_date, y = dv_hms, fill = consumption_kWh)) +
  geom_tile() +
  theme(legend.position = "bottom") +
  scale_fill_viridis_c(name = "Electricity import (kWh)") +
  labs(x = "Date",
       y = "Half-hour")

plotly::ggplotly(p)

plotDT[, dow := lubridate::wday(dv_date, label = TRUE)]
recent_dt <- plotDT[, .(sum_kWh_elec = sum(consumption_kWh)), keyby = .(dv_date, dow, dv_peakPeriod)]
daily_totals <- plotDT[, .(Total = sum(consumption_kWh)), keyby = .(dv_date, dow)]

t <- dcast(recent_dt, dv_date + dow ~ dv_peakPeriod, val.var = sum_kWh_elec)
# add totals
t <- t[daily_totals]
makeFlexTable(t, digits = 2,
              cap = "Recent electricity use")

daily_totals[, fuel := "elec"]  # for future use


p <- ggplot2::ggplot(recent_dt, aes(x = dv_date, 
                                    y = sum_kWh_elec, fill = dv_peakPeriod)) +
  geom_col(position = "stack") +
  scale_fill_viridis_d(name = "Time of day") +
  scale_x_date(date_breaks = "1 day", date_labels =  "%a %b %d") +
  theme(axis.text.x = element_text(angle = 90)) +
labs(x = "Date",
     y = "Electricity kWh")

plotly::ggplotly(p)
```


### Daily analysis

```{r plotTotalElecImportDailyRecent, fig.cap="Mean half-hourly electricity import per day (kWh, last 2 weeks)"}

plotDT <- elecCons_dt[dv_date > Sys.Date()-14, .(sum_kWh = sum(consumption_kWh),
                          mean_kWh = mean(consumption_kWh),
                          nObs = .N), keyby = .(dv_date)]

ggplot2::ggplot(plotDT, aes(x = dv_date, y = sum_kWh)) +
  geom_col() +
  #facet_grid(dv_peakPeriod ~ .) +
  labs(x = "Date",
       y = "Daily kWh")
```

Figure \@ref(fig:plotTotalElecImportDaily) shows the total daily kWh import with a smoothed curve for each day as shown.

```{r plotTotalElecImportDaily, fig.cap="Mean half-hourly electricity import per day (kWh, current year)", warning=FALSE}
elecCons_dt[, dv_month := lubridate::month(dv_date, label = TRUE)]
elecCons_dt[, dv_year := lubridate::year(dv_date)]
elecCons_dt[, dv_yday := lubridate::yday(dv_date)]
plotDT <- elecCons_dt[, .(sum_kWh = sum(consumption_kWh),
                          mean_kWh = mean(consumption_kWh),
                          nObs = .N), keyby = .(dv_yday, dv_month, dv_year)]

makeDailyPlotByYear <- function(dt){
  # expects a plotDT with y = sum_kWh
  p <- ggplot2::ggplot(plotDT, aes(x = dv_yday, y = sum_kWh, 
                            colour = dv_month,
                            linetype = as.factor(dv_year),
                            alpha = dv_year)) +
  geom_line() +
  geom_smooth() +
  #facet_grid(dv_year ~ .) +
  theme(legend.position = "bottom") +
  scale_colour_viridis_d(name = "Month") +
  scale_linetype_discrete(name = "Year") +
  scale_alpha_continuous(guide = "none") +
  #scale_alpha_discrete(name = "Year") +
  labs(x = "Day of the year",
       y = "Daily kWh")
  
  return(p)
}

makeDailyPlotByYear(plotDT)

```

Figure \@ref(fig:plotElecImportDailyByPeriod) shows the mean daily kWh import with a smoothed curve for each period as defined below. The periods do not have the same number of half-hours so we use the mean as a comparator.

`Early morning` is effectively our baseload.

```{r checkPeriods}
# check periods
t <- elecCons_dt[, .(min = min(dv_hms),
                     max = max(dv_hms)),
                 keyby = .(dv_peakPeriod)]
t

t <- elecCons_dt[, .(mean_kWh = mean(consumption_kWh),
                     sd_kWh = sd(consumption_kWh),
                     min_kWh = min(consumption_kWh),
                     max_kWh = max(consumption_kWh)),
                 keyby = .(dv_peakPeriod)]
makeFlexTable(t, digits = 3, cap = "Summary stats (all half-hourly data)")
```


```{r plotElecImportDailyByPeriod, fig.cap="Mean half-hourly electricity import (kWh) by peak period (current year)"}

plotDT <- elecCons_dt[, .(sum_kWh = sum(consumption_kWh),
                          mean_kWh = mean(consumption_kWh),
                          nObs = .N), keyby = .(dv_date, dv_peakPeriod)]
totalDT <- elecCons_dt[, .(sum_kWh = sum(consumption_kWh),
                           mean_kWh = mean(consumption_kWh),
                           nObs = .N), keyby = .(dv_date)]
totalDT[, dv_peakPeriod := "All periods"]

plotDT <- rbind(plotDT, totalDT)

ggplot2::ggplot(plotDT, aes(x = dv_date, y = mean_kWh, 
                            colour = dv_peakPeriod)) +
  geom_line() +
  geom_smooth() +
  #facet_grid(dv_peakPeriod ~ .) +
  theme(legend.position = "bottom") +
  guides(colour = guide_legend (ncol = 3)) +
  scale_colour_viridis_d(name = "Peak period") +
  labs(x = "Date",
       y = "Mean kWh per half-hour")
```

What's happening here?

* we have PV (but not a lot) -> summer `Day time`
* we switched from a gas hob to induction in July -> `evening peak`
* we got rid of a freezer with a bad seal in July (-> `early morning baseload`) and also swapped a built-in fridge-freezer for a stand-alone fridge (& freezer)
* we set the hot water circulation loop to 'just in time' (`morning peak`). Well, kind of. Might affect the gas more.

### PV generation

Not Octopus data - irregular reads by us. Load from .xslsx

Figure \@ref(fig:getPVgen) compares our PV generation with overall grid import. These are mean values. We are occasionally exporting (Table \@ref(tab:elecTotal) has zeros) but we do not (currently) have access to the export data.

```{r getPVgen, fig.cap="Compare grid import and PV gen"}
library(openxlsx)
f <- "~/Dropbox/Home/houses/whiteHorseMews/2WhiteHorseMewsRunningCosts.xlsx"
pvGen <- openxlsx::read.xlsx(f,
                             sheet = "PV",
                             detectDates = TRUE)
pvGen_DT <- data.table::as.data.table(pvGen)
pvGen_DT[, meankWhGen := diff/n.days]
pvGen_DT[, dv_date := lubridate::as_datetime(Date)]
pvGen_DT[, month := lubridate::month(dv_date)]

monthlyPvGen_DT <- pvGen_DT[, .(hh_meankWh = mean(meankWhGen)/48 # input value is mean per day
),
keyby = .(month = lubridate::month(dv_date),
          year = lubridate::year(dv_date))
]
monthlyPvGen_DT[, value := "PV generation"]

monthlyElec_DT <- elecCons_dt[, .(hh_meankWh = mean(consumption_kWh)),
                              keyby = .(month = lubridate::month(dv_date),
                                        year = lubridate::year(dv_date))]
monthlyElec_DT[, value := "Grid import"]

plotDT <- rbind(monthlyPvGen_DT, monthlyElec_DT)

ggplot2::ggplot(plotDT, aes(x = lubridate::month(month, label = TRUE), y = hh_meankWh, 
                            colour = value, group = value)) +
  geom_line()+
  scale_color_discrete(name = "Type")+
  facet_grid(year ~ .) +
  labs(x = "Month")
```

> To do: model value of PV gen if we were to use all of it. 

### PV Export

This will be a new MPAN but specified as export - although the url will still say `consumption`. We do not have this even though the PV is exporting on (some) days.

It may be that we only get this data if we sign up for the export tariff.

See https://www.guylipman.com/octopus/api_guide.html#s3

```{r getElecExport}

```

```{r plotElecExport}

```


### Electricity emissions

In theory our emissions from electricity use are zero because we are on a renewable-only tariff. But life is not so simple. We don't have a private wire to a wind turbine so the electrons we import (stick with it) are as averagely green as all the rest.

We also con't avoid the 'Well To Tank' emissions and those associated with transmission losses.

To further complicate things there are at least two different ways to estimate our emissions.

* use the annual BEIS emissions factor and multiply by the kWh in question - be it half-hourly, daily, annual, whatever. That's the simple way.
* use the NG-ESO half-hourly emissions factors which reflect the generation mix (with some caveats) of the grid at half-hourly intervals

`Does it matter?` you cry. Well it might. If we've been able to 'flex' our usage in line with \@[theBakingForecast](https://twitter.com/baking4cast) then who knows, maybe we'll be concentrating our usage in times when the grid is actually drawing on more renewables.

So let's take a look. We'll do both the BEIS-based and NG-ESO based calculations to see. For now we'll ignore the WTT and the T&D losses to keep the results comparable. We'll come back to that later.

```{r setBEISelec}
rmdParams$BEIS_elec_ci <-   0.21233 
```

For the BEIS method, we'll have to use the [2021 emissions factor](https://www.gov.uk/government/collections/government-conversion-factors-for-company-reporting) as the 2022 value is not yet available.

For 2021 this is: `r rmdParams$BEIS_elec_ci` Kg CO2e/kWh

For the NG-ESO method we use the NG-ESO [half-hourly carbon intensity data](https://data.nationalgrideso.com/carbon-intensity1/historic-generation-mix) that match to the half-hours in our electricity use dataset.

Mean half-hourly carbon intensity from the NG-ESO data for the data period was `r round(mean(elecCons_dt$CARBON_INTENSITY, na.rm = TRUE)/1000,4)` Kg CO2e/kWh. If this is substantially different to  the BEIS 2021 value of `r round(rmdParams$BEIS_elec_ci,4)` Kg CO2e/kWh, we would  expect emissions estimates using the NG-ESO factor to differ.

```{r mergeData}
# merge to usage data
setkey(ngeso_dt_orig, dv_start)
setkey(elecCons_dt, dv_start)
elecCons_dt <- ngeso_dt_orig[, .(dv_start, CARBON_INTENSITY, LOW_CARBON_perc, RENEWABLE_perc)][elecCons_dt] # keeps match to our electricity use

# there will be NAs if some datetimes are missing from ngeso_dt_orig
```

For context, Figure \@ref(fig:ngesoMonthly) summarises the mean half-hourly carbon intensity by month for the data period. We can clearly see that February 2022 was a very low carbon month... in fact it was a [very windy month with 3 named storms](https://www.metoffice.gov.uk/binaries/content/assets/metofficegovuk/pdf/weather/learn-about/uk-past-events/summaries/uk_monthly_climate_summary_202202a.pdf).

```{r ngesoMonthly, fig.cap="Monthly mean carbon intensity for the data period by month (NG-ESO data)"}
elecCons_dt[, dv_month := lubridate::month(dv_date, label = TRUE)]
ggplot2::ggplot(elecCons_dt, aes(x = dv_month, y = CARBON_INTENSITY)) +
  geom_violin(draw_quantiles = c(0.5)) +
  #geom_jitter() +
  #geom_boxplot() +
  labs(x = "Month",
       y = "Half-hourly carbon intensity",
       caption = "Median drawn")

```

Figure \@ref(fig:renewableConsumption) shows our half-hourly electricity kWh use vs halfhourly carbon intensity. Ideally we want a negative correlation showing that we use the most electricity when it is 'greenest' (carbon intensity is lowest). Doesn't look too good, aye?

```{r renewableConsumption, fig.cap = "Own half-hourly electricity kWh vs NG-ESO halfhourly carbon intensity"}
ggplot2::ggplot(elecCons_dt, aes(x = CARBON_INTENSITY, y = consumption_kWh, colour = RENEWABLE_perc)) +
  geom_point() +
  facet_wrap(. ~ dv_peakPeriod) +
  geom_smooth() +
  scale_color_continuous(name = "% renewables", low = "red", high = "green") +
  theme(legend.position = "bottom") +
  labs(y = "Halfhourly electricity kWh")

```

What if we visualise using a box plot according to carbon intensity decile? So this means we divide the carbon intensity values into 10 equal groups - deciles. This is Figure \@ref(fig:halfhourlyCIbox). Doesn't look too good either - our median usage (the horizontal bar in the boxes) seems to trend slightly upwards as we move to higher carbon intensity deciles.

```{r halfhourlyCIbox, fig.cap="Boxing clever"}
# this will generate NAs if the CI data is missing for some of the (most recent) dateTimes 
elecCons_dt[, CI_deciles := cut_number(CARBON_INTENSITY, n = 10)]

ggplot2::ggplot(elecCons_dt, aes(x = CI_deciles, y = consumption_kWh)) +
  geom_boxplot() +
  labs(y = "Halfhourly electricity kWh",
       x = "Carbon intensity decile")
```

So what if we just add up all our electricity kWh by carbon intensity decile? Do we use more low carbon kWh? This is Figure \@ref(fig:consSum). Nah. The bakingforecast isn't going to like us...

```{r consSum, fig.cap="Sum of electricity kWh by carbon intensity decile"}
t <- elecCons_dt[, .(sumkWh = sum(consumption_kWh, na.rm = TRUE),
                     meankWh = mean(consumption_kWh, na.rm = TRUE)),
                 keyby = .(CI_deciles)]

ggplot2::ggplot(t, aes(x = CI_deciles, y = sumkWh)) +
  geom_col() +
  labs(y = "Sum kWh",
       x = "Carbon intensity decile")
```

Out of interest, do our emissions values look very different if we apply the BEIS 2021 annual factor to our total electricity kWh to date compared to applying the NG-ESO half-hourly values?

```{r compareMethods}
elecCons_dt[, KgCO2_ngeso := consumption_kWh * (CARBON_INTENSITY/1000)] # convert to kg
t <- elecCons_dt[, .(sumkWh = sum(consumption_kWh),
                     sumKgCO2_ngeso = sum(KgCO2_ngeso, na.rm = TRUE))]

t[, sumKgCO2_beis :=  sumkWh * rmdParams$BEIS_elec_ci]

makeFlexTable(t, cap = "Comparing emissions estimation methods using electricity kWh to date")

t <- elecCons_dt[, .(sumkWh = sum(consumption_kWh),
                     sumKgCO2_ngeso = sum(KgCO2_ngeso, na.rm = TRUE)),
                 keyby = .(dv_month)]

t[, sumKgCO2_beis :=  sumkWh * rmdParams$BEIS_elec_ci]

plotDT <- melt(t, id.vars = "dv_month")

ggplot2::ggplot(plotDT[ variable != "sumkWh",], aes(x = dv_month, y = value, fill = variable)) +
  geom_col(position = "dodge") +
  scale_color_discrete(name = "Method") +
  labs(y = "Kg CO2",
       x = "Month")


```

As we'd expect from the comparison of the values above, Table \@ref(tab:compareMethods) suggests that it does. In fact our 'in use' NG-ESO based emissions are `r round(100*(t$sumKgCO2_ngeso/t$sumKgCO2_beis),2)` % of our BEIS-based emissions depending on the month in question.

If we compare the monthly values we can see the biggest difference was in February, a month we have already identified as being more 'low carbon' (see Figure \@ref(fig:ngesoMonthly)).

### Electricity costs (estimates)

Analyse costs using:

* tariff up to 21/11/2022 - £0.2408 /kWh & £0.2401 /day (All rates inc. VAT)
* tariff from 22/11/2022 https://octopus.energy/blog/energy-price-cap-oct-2022/#flexibleoct22rates (_Eastern_)

The latter are slightly different from the assumed to be at UK price cap: £0.34 / kWh & £0.46 ( see [Ofgem](https://www.ofgem.gov.uk/information-consumers/energy-advice-households/check-if-energy-price-cap-affects-you))

```{r setCosts}
prices <- readxl::read_xlsx(here::here("data", "prices.xlsx"))
pricesDT <- data.table::as.data.table(prices)
```

Yes, I know I can extract our exact tariff from the octopus API...

```{r dailyElecCosts, fig.cap="Daily electricity costs"}
daily_elec <- elecCons_dt[, .(sum_kWh = sum(consumption_kWh, na.rm = TRUE), # beware missing (N/A) may decrease sum
                              nObs = .N), keyby = .(dv_date)]

# extract from pricesDT
# must be an easier way

daily_elec[, kwh_p := ifelse(dv_date < lubridate::as_date("2022-11-21"),
                             pricesDT[fuel == "elec" & component == "kWh" &
                                        dateEnd == "2022-11-21", price],
                             pricesDT[fuel == "elec" & component == "kWh" &
                                        dateStart == "2022-11-22", price])]
daily_elec[, sc_p := ifelse(dv_date < lubridate::as_date("2022-11-21"),
                            pricesDT[fuel == "elec" & component == "sc" &
                                       dateEnd == "2022-11-21", price],
                            pricesDT[fuel == "elec" & component == "sc" &
                                       dateStart == "2022-11-22", price])]

daily_elec[, cost := ((sum_kWh * kwh_p) + sc_p)]
daily_elec[, month := lubridate::month(dv_date, label = TRUE)]

ggplot2::ggplot(daily_elec, aes(x = dv_date, y = cost, colour = month)) +
  geom_line() +
  geom_smooth() +
  geom_vline(xintercept = lubridate::as_date("2022-11-21")) +
  labs(y = "Electricity daily cost £",
       caption = "Tariff change/price cap/EPG 2022 date shown\nSmoothed within month")

lastWeek <- max(daily_elec$dv_date) - 7

makeFlexTable(daily_elec[dv_date > lastWeek, .(dv_date, 
                                               day = lubridate::wday(dv_date, label = TRUE),
                                               sum_kWh, nObs, cost)], digits = 2,
              cap = "Recent daily gas cost")
```

```{r monthlyElecCost, fig.cap="Monthly electricity costs"}
daily_elec[, month_floor := lubridate::floor_date(dv_date, "months")]
monthly_elec <- daily_elec[, .(sum_kWh = sum(sum_kWh),
                               cost = sum(cost)),
                           keyby = .(month_floor)]

ggplot2::ggplot(monthly_elec, aes(x = month_floor, y = cost)) +
  geom_col() +
  geom_vline(xintercept = lubridate::as_date("2022-11-01")) +
  labs(y = "Monthly cost £",
       x = "Month", 
       caption = "Tariff change/price cap/EPG 2022 date shown\nBeware incomplete months")
```


```{r elecTotal}

message("Projected annual elec total kWh")
projAnnual_elec_kWh <- mean(daily_elec$sum_kWh)*365
projAnnual_elec_kWh

message("########")
message("# Prices to 21st Nov 2022")

# get_price <- function(dt, fuel, component, dateEnd){
#   p <- dt[fuel == fuel &
#             component == component &
#             dateEnd  == dateEnd,
#           price]
#   return(p)
# }

kWh_p <- pricesDT[fuel == "elec" & component == "kWh" &
                    dateEnd == "2022-11-21", price]
sc_p <- pricesDT[fuel == "elec" & component == "sc" &
                   dateEnd == "2022-11-21", price]

message("Projected annual elec cost @ £ ", kWh_p,
        " per kWh & standing charge at £ ", sc_p,
        " per day")


projAannualCost <- (projAnnual_elec_kWh*kWh_p)+(365*sc_p) # standing charge
projAannualCost
message("Mean projected monthly cost: £")
projAannualCost/12

message("########")
message("# From to 22nd Nov 2022 - prioce cap")
kWh_p <- pricesDT[fuel == "elec" & component == "kWh" &
                    dateStart == "2022-11-22", price]
sc_p <- pricesDT[fuel == "elec" & component == "sc" &
                   dateStart == "2022-11-22", price]

message("Projected annual elec cost @ £ ", kWh_p,
        " per kWh & standing charge at £ ", sc_p,
        " per day")

annualCost_elecCapped <- (projAnnual_elec_kWh*kWh_p)+(365*sc_p) # standing charge
annualCost_elecCapped
message("Projected mean monthly £ under price cap")
monthlyCost_capped <- annualCost_elecCapped/12
monthlyCost_capped

message("That's an increase of ", round(100*((annualCost_elecCapped-projAannualCost)/projAannualCost),2),  " % points")

```

> TO DO: fix £ analysis to use tariff from API

URL will be something like

https://api.octopus.energy/v1/products/LOYAL-FIX-12M-21-10-07/electricity-tariffs/E-1R-LOYAL-FIX-12M-21-10-07-A/standard-unit-rates/

### Winter 2022/2023 SavingsSessions

> Can we [flex](https://twitter.com/tom_rushby/status/1589653290609913856) any of the above for ~ £3/kWh?

Instigated by UK National gird, implemented (in our case) by Octopus- https://twitter.com/SavingSessions

#### 15th Nov 2022

```{r setFunctions}
pd <- function(t){ # make a pretty date
  strftime(t, "%a %d %b %Y")
}
pdt <- function(t){ # make a pretty date
  strftime(t, "%a %d %b %Y %H:%M")
}

# re-usable plot function
make_kwhComparisonPlot <- function(dt, # half hourly smart meter data
                                   startDateTime, # start
                                   endDateTime, # end
                                   timeLag = 10){ # n days to compare against 
  res <- list() # results holder
  
    sessionDate <- lubridate::date(startDateTime) # you'll see why
  if(lubridate::wday(startDateTime) < 6){
    sessionDay <- "weekday" # you'll see why
  } else {
    sessionDay <- "weekend"
  }
  # 1 = Sunday, 7 = Saturday etc
  dt[, ba_wday := lubridate::wday(dv_start, label = TRUE)]
  dt[, ba_wd := ifelse(lubridate::wday(dv_start) > 1 & lubridate::wday(dv_start) < 7,
                       "weekday",
                       "weekend")]
  # extract and aggregate baseline
  # first get similar days (weekdays or weekends as needed)
  
  similarDays <- dt[dv_date != sessionDate & ba_wd == sessionDay &
                      dv_date < sessionDate]
  uniqueN(similarDays$dv_date)
  dates <- tail(similarDays[,(nObs = .N), keyby = .(dv_date)], timeLag) # get the most recent n = timeLag days
  datesToGet <- dates[, dv_date]
  daysWeWant <- similarDays[dv_date %in% datesToGet]
  uniqueN(daysWeWant$dv_date)
  
  
  baseline_meanHalfHourlyDT <- daysWeWant[, 
                                                .(mean_kWh_elec = mean(consumption_kWh),
                                                  minDate = min(dv_date),
                                                  maxDate = max(dv_date)), 
                                                keyby = .(hms = dv_hms)]
  res$nCompDays <- uniqueN(daysWeWant$dv_date)
  
  baseline_meanHalfHourlyDT[, legend_lab := paste0("Comparison mean")]
  
  # extract session day
  session_HalfHourlyDT <- dt[dv_date == lubridate::date(startDateTime),  #  the session day
                                      .(mean_kWh_elec = mean(consumption_kWh),
                                                  minDate = min(dv_date),
                                                  maxDate = max(dv_date)), 
                                      keyby = .(hms = dv_hms)]
  session_HalfHourlyDT[, legend_lab := "Saving session"]
  
  plotDT <- rbind(baseline_meanHalfHourlyDT, session_HalfHourlyDT)
  
  plotDT[, adjusted_hms := hms::as_hms(hms + (15*60))] # plots points in centre of half-hour period for clarity
  
  periodAlpha <- 0.3 #  shaded rects on plots
  periodFill <- "grey50"
    ymax <- max(plotDT$mean_kWh_elec)
    ymin <- min(plotDT$mean_kWh_elec)
    xmin <- hms::as_hms(lubridate::as_datetime(startDateTime))
    xmax <- hms::as_hms(lubridate::as_datetime(endDateTime)) + 30*60 # to allow for the start time
    
    # make the table before we muck about for the plot
    t <- plotDT[hms >= xmin & hms < xmax]
    
    wt <- dcast(t[, .(hms, wday, mean_kWh_elec, legend_lab)], hms ~ legend_lab, value.var = "mean_kWh_elec")
    
    wt[, kwh_diff := `Saving session` - `Comparison mean`]
    res$wt <- wt[, pc_diff := 100*(kwh_diff/`Comparison mean`)] # add to results holder for return
    
    label <- paste0("Saving session (", 
                    as.Date(startDateTime),
                    ")"
    )
    plotDT[, legend_lab := ifelse(legend_lab == "Saving session",
                                  label,
                                  legend_lab)]
    
    res$p <- ggplot2::ggplot(plotDT, aes(x = adjusted_hms, y = mean_kWh_elec, 
                                         colour = legend_lab)) +
      geom_line() +
      geom_point() +
      annotate("rect", xmin = xmin,
               xmax = xmax,
               ymin = ymin, ymax = ymax,
               alpha = periodAlpha, fill = periodFill) +
      scale_color_manual(name = "Legend", values=c('grey', 'red')) + # this should always make comparison grey
      theme(legend.position = "bottom") +
      labs(x = "Time of day",
           y = "Mean kWh per half-hour",
           caption = paste0("Data: @OctopusEnergy\nPlot: @dataknut\nPoints centered in half-hours for clarity\nComparison = ", res$nCompDays," previous days (",
                            pd(min(daysWeWant$dv_date)), " - ",
                                pd(max(daysWeWant$dv_date)), ")"
                            )
      )
    
    return(res)
}

startDateTime <- "2022-11-15 17:00:00" # the half-hour it starts
endDateTime <- "2022-11-15 17:30:00" # the half-hour it ends (makes data selection easier)
gbp_rate <- 2.50

periodStr <- paste0(pdt(startDateTime), " - ", strftime(lubridate::as_datetime(endDateTime)+30*60, "%H:%M"))
```

> From `r periodStr`

> Rate: £`r gbp_rate`/kWh

Figure \@ref(fig:firstSavingSessionsUsage) shows how we did in the first #SavingSessions **compared to the last 10 similar days**.

> NB: this may not be quite the same as the Octopus algorithm

```{r firstSavingSessionsUsage, fig.cap="First #SavingSessions - how did we do?"}

res <- make_kwhComparisonPlot(elecCons_dt, startDateTime, endDateTime)
res$p # the plot

  totalSavingKWh <- sum(res$wt$kwh_diff)
  totalSavingGBP <- round(sum(res$wt$kwh_diff) * gbp_rate,2)
  
  sumSavings <- totalSavingGBP
```

Total saving: `r totalSavingKWh` kWh

Total prize: £ `r totalSavingGBP`

```{r}
makeFlexTable(res$wt[, hms:= as.factor(hms)], 
              cap = paste0("kWh comparisons (hms = half hour period start, comparison = ", res$nCompDays," previous days)"),
              digits = 3) # the table
```

> What do we conclude? 

> For a complicated set of pre-Xmas prep reasons (and poor institutional memory) our electricity usage in the late afternoon was much *higher* than usual on the session day. As a result our actions only brought usage down to 'average' for this time on a Tuesday (so we won't win any points). But as a result our usage was probably **way lower** than it otherwise would have been judging by the spikes before and after. So if it really had been a critical peak event, we would have been helping the system but not being rewarded...


#### 22nd Nov 2022 - missed it :-(


```{r}
startDateTime <- "2022-11-22 17:30:00" # the half-hour it starts
endDateTime <- "2022-11-22 18:00:00" # the half-hour it ends (makes data selection easier)

gbp_rate <- 2.25

periodStr <- paste0(pdt(startDateTime), " - ", strftime(lubridate::as_datetime(endDateTime)+30*60, "%H:%M"))
```

> From `r periodStr`

> Rate: £`r gbp_rate`/kWh

We missed this one but Figure \@ref(fig:secondSavingSessionsUsage) shows how we would have done in this #SavingSession compared to the last n similar days of the week - had we signed up.

```{r secondSavingSessionsUsage, fig.cap="Second #SavingSessions - how would we have done?"}
if(as.Date(startDateTime) < Sys.Date()){ # octopus data only available for day before
  data <- TRUE
  res <- make_kwhComparisonPlot(elecCons_dt, 
                                startDateTime, endDateTime)
  
  print(res$p) # the plot
  totalSavingKWh <- sum(res$wt$kwh_diff)
  totalSavingGBP <- round(sum(res$wt$kwh_diff) * gbp_rate,2)
} else {
  data <- FALSE
  theMsg <- "Data not yet available, try later :-("
  message(theMsg)
  totalSavingKWh <- theMsg
  totalSavingGBP <- theMsg
}
```

> What do we conclude? 

 * we would have done quite well after 18:00 :-)
 
Total saving: `r totalSavingKWh` kWh

Total prize: £ `r totalSavingGBP`

```{r}
if(data){ # set above
  makeFlexTable(res$wt[, hms:= as.factor(hms)], 
                cap = paste0("kWh comparisons (hms = half hour period start, comparison = ", res$nCompDays," previous days"),
                digits = 3) # the table
} else {
  message("Data not yet available, try later :-(")
}
```


#### 30th Nov 2022

```{r}
startDateTime <- "2022-11-30 17:30:00" # the half-hour it starts
endDateTime <- "2022-11-30 18:00:00" # the half-hour it ends (makes data selection easier)
gbp_rate <- 2.50
periodStr <- paste0(pdt(startDateTime), " - ", strftime(lubridate::as_datetime(endDateTime)+30*60, "%H:%M"))
```

> From `r periodStr`

> Rate: £`r gbp_rate`/kWh

Figure \@ref(fig:thirdSavingSessionsUsage) shows how we did in the third #SavingSessions compared to the last n similar days of the week.

```{r thirdSavingSessionsUsage, fig.cap="Third #SavingSessions - how did we do?"}
res <- make_kwhComparisonPlot(elecCons_dt, startDateTime, endDateTime)
res$p # the plot

totalSavingKWh <- sum(res$wt$kwh_diff)
totalSavingGBP <- round(sum(res$wt$kwh_diff) * gbp_rate,2)
  
sumSavings <- totalSavingGBP + sumSavings
```

> What do we conclude? 

 * Total saving: `r totalSavingKWh` kWh
 * Total prize: £ `r totalSavingGBP`
 * Cost centre #3 rushed home to get a toastie & his laundry in on the 30@30 cycle before 17:00 and then went to rugby training
 * Cost centre #4 went to the gym & stayed there until 20:00
 * Our dinner guest was happy to delay cooking & eating slightly
 
```{r}
makeFlexTable(res$wt[, hms:= as.factor(hms)], 
              cap = paste0("kWh comparisons (hms = half hour period start, comparison = ", res$nCompDays," previous days"),
              digits = 3) # the table
```



#### 1st Dec 2022

```{r}
startDateTime <- "2022-12-01 17:00:00" # the half-hour it starts
endDateTime <- "2022-12-01 17:30:00" # the half-hour it ends (makes data selection easier)

gbp_rate <- 2.50
periodStr <- paste0(pdt(startDateTime), " - ", strftime(lubridate::as_datetime(endDateTime)+30*60, "%H:%M"))
```

> From `r periodStr`

> Rate: £`r gbp_rate`/kWh

Figure \@ref(fig:fourthSavingSessionsUsage) shows how we did in this #SavingSession compared to the last n similar days of the week.

```{r fourthSavingSessionsUsage, fig.cap="Fourth #SavingSessions - how did we do?"}

res <- make_kwhComparisonPlot(elecCons_dt, startDateTime, endDateTime)
res$p # the plot
```

> What do we conclude? 

 * Cost centre #3 didn't come home at all until 22:00
 * Cost centre #4 went to the gym and cooked with Cost centre #3 at 22:00
 * Our 2nd dinner guest of the week was also happy to delay cooking & eating slightly!
 * We contributed to the post-saving session surge at 18:00
 
Total saving: `r sum(res$wt$kwh_diff)` kWh

Total prize: £ `r round(sum(res$wt$kwh_diff) * gbp_rate,2)`

```{r}
makeFlexTable(res$wt[, hms:= as.factor(hms)], 
              cap = paste0("kWh comparisons (hms = half hour period start, comparison = ", res$nCompDays," previous days"),
              digits = 3) # the table
```


#### 12th Dec 2022

```{r}
startDateTime <- "2022-12-12 17:00:00" # the half-hour it starts
endDateTime <- "2022-12-12 17:30:00" # the half-hour it ends (makes data selection easier)

gbp_rate <- 2.50
periodStr <- paste0(pdt(startDateTime), " - ", strftime(lubridate::as_datetime(endDateTime)+30*60, "%H:%M"))
```

> From `r periodStr`

> Rate: £`r gbp_rate`/kWh


Figure \@ref(fig:fifthSavingSessionsUsage) shows how we did in this #SavingSession compared to the last n similar days of the week.

```{r fifthSavingSessionsUsage, fig.cap="Fifth #SavingSessions - how did we do?"}
res <- make_kwhComparisonPlot(elecCons_dt, startDateTime, endDateTime)
res$p # the plot
```

> What do we conclude? 

 * Pre-planned trip to Grandma's worked well...
 * Our early December mornings were using a lot of electricity.
 
Total saving: `r sum(res$wt$kwh_diff)` kWh

Total prize: £ `r round(sum(res$wt$kwh_diff) * gbp_rate,2)`

```{r}
makeFlexTable(res$wt[, hms:= as.factor(hms)], 
              cap = paste0("kWh comparisons (hms = half hour period start, comparison = ", res$nCompDays," previous days"),
              digits = 3) # the table
```



#### 19th Jan 2023 - missed it :-(

```{r}
startDateTime <- "2023-01-19 09:00:00" # the half-hour it starts
endDateTime <- "2023-01-19 09:30:00" # the half-hour it ends (makes data selection easier)

gbp_rate <- 2.50

periodStr <- paste0(pdt(startDateTime), " - ", strftime(lubridate::as_datetime(endDateTime)+30*60, "%H:%M"))
```

> From `r periodStr`

> Rate: £`r gbp_rate`/kWh

Figure \@ref(fig:sixthSavingSessionsUsage) shows how we _would have done had we entered_ for this #SavingSession compared to the last n similar days of the week.

```{r sixthSavingSessionsUsage, fig.cap="Sixth #SavingSessions - how would we have done?"}

res <- make_kwhComparisonPlot(elecCons_dt, startDateTime, endDateTime)
res$p # the plot
```

> What do we conclude? 

 * Randomly we would have saved a bit at 09:00!
 
Total saving: `r sum(res$wt$kwh_diff)` kWh

Total prize: £ `r round(sum(res$wt$kwh_diff) * gbp_rate,2)`

```{r}
makeFlexTable(res$wt[, hms:= as.factor(hms)], 
              cap = paste0("kWh comparisons (hms = half hour period start, comparison = ", res$nCompDays," previous days"),
              digits = 3) # the table
```



#### 23rd Jan 2023

```{r}
startDateTime <- "2023-01-23 17:00:00" # the half-hour it starts
endDateTime <- "2023-01-23 17:30:00" # the half-hour it ends (makes data selection easier)

gbp_rate <- 3.37
periodStr <- paste0(pdt(startDateTime), " - ", strftime(lubridate::as_datetime(endDateTime)+30*60, "%H:%M"))
```

> From `r periodStr`

> Rate: £`r gbp_rate`/kWh

Figure \@ref(fig:seventhSavingSessionsUsage) shows how we did in this #SavingSession compared to the last n similar days of the week.

```{r seventhSavingSessionsUsage, fig.cap="Seventh #SavingSessions - how did we do?"}
if(as.Date(startDateTime) < Sys.Date()-1){ # data only available 24 hours later
  data <- TRUE
  res <- make_kwhComparisonPlot(elecCons_dt, 
                                startDateTime, endDateTime)
  
  print(res$p) # the plot
  totalSavingKWh <- sum(res$wt$kwh_diff)
  totalSavingGBP <- round(sum(res$wt$kwh_diff) * gbp_rate,2)
} else {
  theMsg <- "Data not yet available, try later :-("
  message(theMsg)
  totalSavingKWh <- theMsg
  totalSavingGBP <- theMsg
}
```

> What do we conclude? 

 * Going for a [deer stalk](https://www.strava.com/activities/8440640672) worked a treat
 * We can't do much about the baseline...
 * As we've seen on previous sessions, our (cooking) 'peak' is usually c. 19:00 so these sessions are a bit early for us - they don't coincide with peak! Our 16:00 pick-up might be the heating/gas boiler pump but more likely it is tea & cake time :-)

Total saving: `r totalSavingKWh` kWh

Total prize: £ `r totalSavingGBP`

```{r}
if(data){ # set above
  makeFlexTable(res$wt[, hms:= as.factor(hms)], 
                cap = paste0("kWh comparisons (hms = half hour period start, comparison = ", res$nCompDays," previous days"),
                digits = 3) # the table
} else {
  message("Data not yet available, try later :-(")
}
```


#### 24th Jan 2023

```{r}
startDateTime <- "2023-01-24 16:30:00" # the half-hour it starts
endDateTime <- "2023-01-24 17:30:00" # the half-hour it ends (makes data selection easier)

gbp_rate <- 4

periodStr <- paste0(pdt(startDateTime), " - ", strftime(lubridate::as_datetime(endDateTime)+30*60, "%H:%M"))
```

> From `r periodStr`

> Rate: £`r gbp_rate`/kWh

Figure \@ref(fig:eighthSavingSessionsUsage) shows how we did in this #SavingSession compared to the last n similar days of the week.

```{r eighthSavingSessionsUsage, fig.cap="Eighth #SavingSessions - how did we do?"}
if(as.Date(startDateTime) < Sys.Date()){ # octopus data only available for day before
  data <- TRUE
  res <- make_kwhComparisonPlot(elecCons_dt, 
                                startDateTime, endDateTime)
  
  print(res$p) # the plot
  totalSavingKWh <- sum(res$wt$kwh_diff)
  totalSavingGBP <- round(sum(res$wt$kwh_diff) * gbp_rate,2)
} else {
  data <- FALSE
  theMsg <- "Data not yet available, try later :-("
  message(theMsg)
  totalSavingKWh <- theMsg
  totalSavingGBP <- theMsg
}
```

> What do we conclude? 

 * not bad - again we're hitting baseline
 * no sign of the boiler pump uptick at 4 so it must be tea & cake (which was earlier today :-)
 * cost centre 3 came home & cooked at 21:30...
 
Total saving: `r totalSavingKWh` kWh

Total prize: £ `r totalSavingGBP`

```{r}
if(data){ # set above
  makeFlexTable(res$wt[, hms:= as.factor(hms)], 
                cap = paste0("kWh comparisons (hms = half hour period start, comparison = ", res$nCompDays," previous days"),
                digits = 3) # the table
} else {
  message("Data not yet available, try later :-(")
}
```

#### 30th Jan 2023 - missed it :-(

```{r}
startDateTime <- "2023-01-30 09:00:00" # the half-hour it starts
endDateTime <- "2023-01-30 09:30:00" # the half-hour it ends (makes data selection easier)

gbp_rate <- 2.25

periodStr <- paste0(pdt(startDateTime), " - ", strftime(lubridate::as_datetime(endDateTime)+30*60, "%H:%M"))
```

> From `r periodStr`

> Rate: £`r gbp_rate`/kWh

We missed this one but Figure \@ref(fig:ninthSavingSessionsUsage) shows how we did in this #SavingSession compared to the last n similar days of the week - had we signed up.

```{r ninthSavingSessionsUsage, fig.cap="Ninth #SavingSessions - how would we have done?"}
if(as.Date(startDateTime) < Sys.Date()){ # octopus data only available for day before
  data <- TRUE
  res <- make_kwhComparisonPlot(elecCons_dt, 
                                startDateTime, endDateTime)
  
  print(res$p) # the plot
  totalSavingKWh <- sum(res$wt$kwh_diff)
  totalSavingGBP <- round(sum(res$wt$kwh_diff) * gbp_rate,2)
} else {
  data <- FALSE
  theMsg <- "Data not yet available, try later :-("
  message(theMsg)
  totalSavingKWh <- theMsg
  totalSavingGBP <- theMsg
}
```

> What do we conclude? 

 * someone put the kettle on at 09:30 :-)
 
Total saving: `r totalSavingKWh` kWh

Total prize: £ `r totalSavingGBP`

```{r}
if(data){ # set above
  makeFlexTable(res$wt[, hms:= as.factor(hms)], 
                cap = paste0("kWh comparisons (hms = half hour period start, comparison = ", res$nCompDays," previous days"),
                digits = 3) # the table
} else {
  message("Data not yet available, try later :-(")
}
```


#### 13th Feb 2023

```{r}
startDateTime <- "2023-02-13 17:30:00" # the half-hour it starts
endDateTime <- "2023-02-13 18:00:00" # the half-hour it ends (makes data selection easier)

gbp_rate <- 2.25

periodStr <- paste0(pdt(startDateTime), " - ", strftime(lubridate::as_datetime(endDateTime)+30*60, "%H:%M"))
```

> From `r periodStr`

> Rate: £`r gbp_rate`/kWh

Figure \@ref(fig:tenthSavingSessionsUsage) shows how we did in this #SavingSession compared to the last n similar days of the week.

```{r tenthSavingSessionsUsage, fig.cap="Tenth #SavingSessions- how did we do?"}
if(as.Date(startDateTime) < Sys.Date()){ # octopus data only available for day before
  data <- TRUE
  res <- make_kwhComparisonPlot(elecCons_dt, 
                                startDateTime, endDateTime)
  
  print(res$p) # the plot
  totalSavingKWh <- sum(res$wt$kwh_diff)
  totalSavingGBP <- round(sum(res$wt$kwh_diff) * gbp_rate,2)
} else {
  data <- FALSE
  theMsg <- "Data not yet available, try later :-("
  message(theMsg)
  totalSavingKWh <- theMsg
  totalSavingGBP <- theMsg
}
```

> What do we conclude? 

 * Solar's back :-)
 * We managed to push cooking back to 18:30
 * Three distinct cooking periods! :-(
 
Total saving: `r totalSavingKWh` kWh

Total prize: £ `r totalSavingGBP`

```{r}
if(data){ # set above
  makeFlexTable(res$wt[, hms:= as.factor(hms)], 
                cap = paste0("kWh comparisons (hms = half hour period start, comparison = ", res$nCompDays," previous days"),
                digits = 3) # the table
} else {
  message("Data not yet available, try later :-(")
}
```

## Gas 'Consumption' (aka `use`)

We need to convert the gas consumption from m3 to kWh - see https://developer.octopus.energy/docs/api/#list-consumption-for-a-meter

```{r set_gasM3TokWh}
gasM3TokWh <- 11.36
```

We use a multiplier of `r gasM3TokWh` kWh/m3 (https://www.theenergyshop.com/guides/how-to-convert-gas-units-to-kwh)

> Check for missing dates and adjust "&page_size=100000" if needed

```{r getGasConsumption}
url <- paste0("https://api.octopus.energy/v1/gas-meter-points/", 
              apiParams$gas_mpan , "/",
              "meters/",
              apiParams$gas_serial, "/",
              "consumption",
              "?period_from=2022-01-01T00:00Z",
              "&page_size=100000") # make sure is large enough
resp <- httr::GET(url = url, authenticate(user = apiParams$key, password = ""))
df <- jsonlite::parse_json(resp, simplifyVector = TRUE)
gasCons_dt <- data.table::as.data.table(df$results)
gasCons_dt <- makeDerivedVars(gasCons_dt)

# gas 'consumption' is m3 - https://developer.octopus.energy/docs/api/#list-consumption-for-a-meter
# convert to kWh
gasCons_dt[, consumption_m3 := consumption]
gasCons_dt[, consumption_kWh := consumption * gasM3TokWh]

message("# Check start and end dates")
summary(gasCons_dt$dv_start)

maxTime <- max(gasCons_dt$dv_start)

hoursAgo <- lubridate::now() - maxTime
```

Note that this data starts later as we finally got the original un-registered smart meter replaced in February 2022.

The data used here is up to `r maxTime`. In general the Octopus API seems to have data up to `midnight last night`.

### Half-hourly anlaysis

Figure \@ref(fig:plotGasImport) shows half-hourly gas import ('consumption') for the current year. The power cuts are even easier to see here. Interestingly the pattern after the gas boiler was serviced in June is more varied. _What did he change_?

```{r plotGasImport, fig.cap="Half-hourly gas consumption (current year)"}
ggplot2::ggplot(gasCons_dt, aes(x = dv_date, y = dv_hms, fill = consumption_kWh)) +
  geom_tile() +
  theme(legend.position = "bottom") +
  scale_fill_viridis_c(name = "Gas import (kWh)") +
  labs(x = "Date",
       y = "Half-hour")
```

Repeat but with just the last 14 days of data - useful for checking recent appliance use and offspring effects.

> Check this really is the last 2 weeks of gas use - there may be gas data errors

```{r plotGasImportHalfHourlyRecent, fig.cap="Half hourly gas import (current year, last 14 days)"}
today <- lubridate::today()
plotDT <- gasCons_dt[dv_date >= max(dv_date) - 14] # last 14 days of data - might not be last 14 days in reality due to data errors
p <- ggplot2::ggplot(plotDT, aes(x = dv_date, y = dv_hms, fill = consumption_kWh)) +
  geom_tile() +
  theme(legend.position = "bottom") +
  scale_fill_viridis_c(name = "Gas import (kWh)") +
  labs(x = "Date",
       y = "Half-hour")

plotly::ggplotly(p)

plotDT[, dow := lubridate::wday(dv_date, label = TRUE)]

recent_dt <- plotDT[, .(sum_kWh_gas = sum(consumption_kWh)), keyby = .(dv_date, dow, dv_peakPeriod)]
daily_totals <- plotDT[, .(sum_kWh_gas = sum(consumption_kWh)), keyby = .(dv_date, dow)]

t <- dcast(recent_dt, dv_date + dow ~ dv_peakPeriod, val.var = sum_kWh_gas)
# add totals
t <- t[daily_totals]
makeFlexTable(t, digits = 2,
              cap = "Recent gas use")

p <- ggplot2::ggplot(recent_dt, aes(x = dv_date, 
                                    y = sum_kWh_gas, fill = dv_peakPeriod)) +
  geom_col(position = "stack") +
  scale_fill_viridis_d(name = "Time of day") +
  scale_x_date(date_breaks = "1 day", date_labels =  "%a %b %d") +
  theme(axis.text.x = element_text(angle = 90)) +
labs(x = "Date",
     y = "Gas kWh")

plotly::ggplotly(p)
```

Compare with temperatures from https://www.accuweather.com/en/gb/framlingham/ip13-9/weather-forecast/330898

### Daily analysis

Figure \@ref(fig:plotGasImportDaily) shows the mean daily kWh import with a smoothed curve.

> To do: mark weekends etc

```{r plotGasImportDaily, fig.cap="Daily gas consumption (current year)"}
gasCons_dt[, dv_month := lubridate::month(dv_date, label = TRUE)]
gasCons_dt[, dv_year := lubridate::year(dv_date)]
gasCons_dt[, dv_yday := lubridate::yday(dv_date)]
plotDT <- gasCons_dt[, .(sum_kWh = sum(consumption_kWh),
                         mean_kWh = mean(consumption_kWh),
                         nObs = .N), keyby = .(dv_yday, dv_month, dv_year)]


makeDailyPlotByYear(plotDT)
```

```{r plotGasImportDailyWeekdays, fig.cap="Daily gas consumption (by weekday, current year)"}
plotDT <- gasCons_dt[, .(sum_kWh = sum(consumption_kWh),
                         mean_kWh = mean(consumption_kWh),
                         nObs = .N), keyby = .(dv_date, dv_weekend)]

ggplot2::ggplot(plotDT, aes(x = dv_date, y = sum_kWh, 
                            colour = dv_weekend)) +
  geom_point() +
  geom_smooth() +
  theme(legend.position = "bottom") +
  guides(colour = guide_legend (ncol = 3)) +
  scale_colour_viridis_d(name = "Weekend") +
  labs(x = "Date",
       y = "Sum kWh per day")
```

Repeat for mean

```{r plotGasImportDailyMean}
ggplot2::ggplot(plotDT, aes(x = dv_date, y = mean_kWh, 
                            colour = dv_weekend)) +
  geom_point() +
  geom_smooth() +
  theme(legend.position = "bottom") +
  guides(colour = guide_legend (ncol = 3)) +
  scale_colour_viridis_d(name = "Weekend") +
  labs(x = "Date",
       y = "Mean kWh per day")
```

Figure \@ref(fig:plotGasImportDailyByPeriod) shows the mean daily kWh import with a smoothed curve by period of the day.

> To do: mark weekends etc

```{r plotGasImportDailyByPeriod, fig.cap="Daily gas consumption by peak period (current year)"}

plotDT <- gasCons_dt[, .(sum_kWh = sum(consumption_kWh),
                         mean_kWh = mean(consumption_kWh),
                         nObs = .N), keyby = .(dv_date, dv_peakPeriod, dv_weekend)]

ggplot2::ggplot(plotDT, aes(x = dv_date, y = mean_kWh, 
                            colour = dv_peakPeriod)) +
  geom_line() +
  geom_smooth() +
  #facet_grid(dv_peakPeriod ~ .) +
  theme(legend.position = "bottom") +
  guides(colour = guide_legend (ncol = 3)) +
  scale_colour_viridis_d(name = "Peak period") +
  labs(x = "Date",
       y = "Mean kWh per period")
```

### Gas emissions

This is much more simple. We can only apply the BEIS 2021 value as there are no time-varying emissions factors for gas.

```{r setBEISgas}
rmdParams$BEIS_gas_ci <- 0.20297 
```

As before, for the BEIS method we'll have to use the [2021 emissions factor](https://www.gov.uk/government/collections/government-conversion-factors-for-company-reporting) as the 2022 value is not yet available.

For 2021 this is: `r rmdParams$BEIS_gas_ci` Kg CO2e/kWh

```{r gasEmissionsTotal}
gasCons_dt[, KgCO2_beis := consumption_kWh * rmdParams$BEIS_gas_ci] 
t <- gasCons_dt[, .(sumkWh = sum(consumption_kWh),
                    sumKgCO2_beis = sum(KgCO2_beis))]

makeFlexTable(t, cap = "Emissions estimation using gas kWh to date")
```

### Gas costs

Analyse costs using:

* tariff up to 21/11/2022 - £0.0719 /kWh & £0.261 /day (All rates inc. VAT)
* tariff from 22/11/2022 https://octopus.energy/blog/energy-price-cap-oct-2022/#flexibleoct22rates (_Eastern_)

The latter are (currently) the same as the at UK price cap: £0.1031 / kWh & £0.2684 ( see [Ofgem](https://www.ofgem.gov.uk/information-consumers/energy-advice-households/check-if-energy-price-cap-affects-you))

Yes, I know I can extract our exact tariff from the octopus API...

```{r dailyGasCosts, fig.cap="Daily gas costs"}

daily_gas <- gasCons_dt[, .(sum_kWh = sum(consumption_kWh, na.rm = TRUE), # beware missing (N/A) may decrease sum
                            nObs = .N), keyby = .(dv_date)]

# extract from pricesDT
# must be an easier way

daily_gas[, kwh_p := ifelse(dv_date < lubridate::as_date("2022-10-04"),
                            pricesDT[fuel == "gas" & component == "kWh" &
                                       dateEnd %like% "2022-10-03", price], # why does it need to be like??
                            pricesDT[fuel == "gas" & component == "kWh" &
                                       dateStart %like% "2022-10-04", price])]
daily_gas[, sc_p := ifelse(dv_date < lubridate::as_date("2022-10-04"),
                           pricesDT[fuel == "gas" & component == "sc" &
                                      dateEnd %like% "2022-10-03", price],
                           pricesDT[fuel == "gas" & component == "sc" &
                                      dateStart %like% "2022-10-04", price])]

daily_gas[, cost := ((sum_kWh * kwh_p) + sc_p)]
daily_gas[, month := lubridate::month(dv_date, label = TRUE)]

ggplot2::ggplot(daily_gas, aes(x = dv_date, y = cost, colour = month)) +
  geom_line() +
  geom_smooth() +
  geom_vline(xintercept = lubridate::as_date("2022-10-04")) +
  labs(y = "Gas daily cost £",
       caption = "Tariff change/price cap/EPG 2022 date shown\nSmoothed within month")
lastWeek <- max(daily_gas$dv_date) - 7

makeFlexTable(daily_gas[dv_date > lastWeek, .(dv_date, 
                                              day = lubridate::wday(dv_date, label = TRUE),
                                              sum_kWh, nObs, cost)], digits = 2,
              cap = "Recent daily gas cost")
```

```{r monthlyGasCosts, fig.cap="Monthly gas costs"}

daily_gas[, month_floor := lubridate::floor_date(dv_date, "months")]
monthly_gas <- daily_gas[, .(sum_kWh = sum(sum_kWh),
                             cost = sum(cost)),
                         keyby = .(month_floor)]

ggplot2::ggplot(monthly_gas, aes(x = month_floor, y = cost)) +
  geom_col() +
  geom_vline(xintercept = lubridate::as_date("2022-10-04")) +
  labs(y = "Monthly cost £",
       x = "Month", 
       caption = "Tariff change/price cap/EPG 2022 date shown\nBeware incomplete months")
```



```{r gasTotal}


message("Projected annual gas total kWh")
projAnnual_gas_kWh <- mean(daily_gas$sum_kWh)*365
projAnnual_gas_kWh

message("########")
message("# Prices to 10th October 2022")

# get_price <- function(dt, fuel, component, dateEnd){
#   p <- dt[fuel == fuel &
#             component == component &
#             dateEnd  == dateEnd,
#           price]
#   return(p)
# }

kWh_p <- pricesDT[fuel == "gas" & component == "kWh" &
                    dateEnd %like% "2022-10-03", price]
sc_p <- pricesDT[fuel == "gas" & component == "sc" &
                   dateEnd %like% "2022-10-03", price]

message("Projected annual gas cost @ £ ", kWh_p,
        " per kWh & standing charge at £ ", sc_p,
        " per day")


projAannualCost <- (projAnnual_gas_kWh*kWh_p)+(365*sc_p) # standing charge
projAannualCost
message("Mean projected monthly cost: £")
projAannualCost/12

message("########")
message("# From 4th Oct 2022 - price cap")
kWh_p <- pricesDT[fuel == "gas" & component == "kWh" &
                    dateStart %like% "2022-10-04", price]
sc_p <- pricesDT[fuel == "gas" & component == "sc" &
                   dateStart %like% "2022-10-04", price]

message("Projected annual gas cost @ £ ", kWh_p,
        " per kWh & standing charge at £ ", sc_p,
        " per day")

annualCost_gasCapped <- (projAnnual_gas_kWh*kWh_p)+(365*sc_p) # standing charge
annualCost_gasCapped
message("Projected mean monthly £ under price cap")
monthlyCost_capped <- annualCost_gasCapped/12
monthlyCost_capped

message("That's an increase of ", round(100*((annualCost_gasCapped-projAannualCost)/projAannualCost),2),  " % points")

```

## Total energy & costs

### Recent daily

Partly in response to: https://twitter.com/heatpolicyrich/status/1603768675223437319

Table \@ref(tab:recentTotalcosts) shows recent usage and costs (see pricing detail above) while Figure \@ref(fig:totalcostsPlot) shows total cost over time.

```{r recentTotalcosts}

daily_gas[, gas_sum_kWh := sum_kWh]
daily_gas[, gas_cost := cost]
daily_elec[, elec_sum_kWh := sum_kWh]
daily_elec[, elec_cost := cost]
daily_gas[, dow := lubridate::wday(dv_date, label = TRUE)]
daily_costs <- daily_gas[, .(dv_date, dow, gas_sum_kWh, gas_cost, month)][daily_elec[,.(dv_date, elec_sum_kWh, elec_cost)]]

daily_costs[, total_kWh := gas_sum_kWh + elec_sum_kWh]
daily_costs[, total_cost := gas_cost + elec_cost]

t <- tail(daily_costs, 10)

makeFlexTable(t, cap = "Latest daily use & cost", digits = 2)
```

The following two plots are both stacked so the height of the columns shows daily totals. Figure \@ref(fig:totalDailyCosts) shows total daily energy costs.

```{r totalDailyCosts, fig.cap = "Total daily electricity & gas costs"}

plotDT <- melt(daily_costs[, .(dv_date, gas_cost, elec_cost)], 
               id.vars = "dv_date")

plotDT[, variable := ifelse(variable == "gas_cost",
                            "Gas £", 
                            "Electricity £")]
plotDT[, variable := factor(variable, levels=c('Electricity £', 'Gas £'))] # re-order so electricity first
ggplot2::ggplot(plotDT, aes(x = dv_date, y = value, fill = variable)) +
  geom_col(position = "stack") +
  geom_vline(aes(xintercept = lubridate::as_date("2022-10-04"), colour = "Gas EPG applied")) +
  geom_vline(aes(xintercept = lubridate::as_date("2022-11-21"), colour = "Electricity EPG applied")) +
  scale_color_discrete(name = "EPG dates") +
  scale_fill_discrete(name = "Energy source") +
  labs(x = "Date",
       y = "Gas + electricity daily cost £",
       caption = "Tariff change/price cap/EPG 2022 date shown")
```

> We're definitely using too much gas for hot water... (no heating in summer)

> Interesting missing gas data

Figure \@ref(fig:totalDailyEnergy) shows total daily kWh.

```{r totalDailyEnergy, fig.cap = "Total daily electricity & gas kWh"}
plotDT <- melt(daily_costs[, .(dv_date, gas_sum_kWh, elec_sum_kWh)], 
               id.vars = "dv_date")
plotDT[, variable := ifelse(variable == "gas_sum_kWh",
                            "Gas kWh", 
                            "Electricity kWh")]
plotDT[, variable := factor(variable, levels=c('Electricity kWh', 'Gas kWh'))] # re-order so electricity first
ggplot2::ggplot(plotDT, aes(x = dv_date, y = value, fill = variable)) +
  geom_col(position = "stack") +
  geom_vline(aes(xintercept = lubridate::as_date("2022-10-04"), colour = "Gas EPG applied")) +
  geom_vline(aes(xintercept = lubridate::as_date("2022-11-21"), colour = "Electricity EPG applied")) +
  scale_color_discrete(name = "EPG dates") +
  scale_fill_discrete(name = "Energy source") +
  labs(x = "Date",
       y = "Gas + electricity daily kWh",
       caption = "")



```


```{r totalDailyEnergyRecent, fig.cap = "Total daily electricity & gas kWh (last 14 days)"}

ggplot2::ggplot(plotDT[dv_date > Sys.Date() - 14], aes(x = dv_date, y = value, colour = variable)) +
  geom_line() +
  scale_colour_discrete(name = "Energy source") +
  labs(x = "Date",
       y = "Gas + electricity daily kWh",
       caption = "")



```


### Monthly

Monthly estimated costs (averaged over 12 months to guide monthly payment value).

These use [the latest Octopus flexible tariff from Oct 2022](https://octopus.energy/blog/energy-price-cap-oct-2022/#flexibleoct22rates) which are protected by the government's Energy Price Guarantee:

```{r pricesTable}
t <- pricesDT[dateStart > as.Date("2022-10-01")]
t[, dateStart := as.Date(dateStart)]
makeFlexTable(t, cap = "Price cap prices", digits = 3)
```

> According to our EPC:

* floor area: 163 m2
* Air permeability 5.0 m³/h.m² (as tested)
* The primary energy use for this property per year is 65 kilowatt hours per square metre (kWh/m2) or `r 163*65` kWh/year (_"Primary energy use is a measure of the energy required for lighting, heating and hot water in a property"_)
* This property produces 1.9 tonnes of CO2 
* Space heating 	6511 kWh per year
* Water heating 	2351 kWh per year 
* total of `r 6511 + 2351` kWh/year

First we'll compare with hot water...

```{r epcComparisonsHotwater}
message("Assume our August-September gas use is just for hot water (almost certainly always true - no gas hob and no heating on)")

hw <- gasCons_dt[dv_date >= as.Date("2022-08-01") &
                   dv_date < as.Date("2022-10-01"), .(daily_kWh = sum(consumption_kWh),
                                                      nObs = .N),
                 keyby = .(dv_date)]

message("Mean daily gas use in this period = ", round(mean(hw$daily_kWh),2), " kWh")
annualHW <- 365 * mean(hw$daily_kWh)
message("So estimated annual gas for hot water = ", round(annualHW), " kWh (assuming constant hot water use all year round)")

message("That's ", round(annualHW/2351,2), " times the EPC estimate of 2351 kWh... ")
```

And now heating...

```{r epcComparisonsSpaceHeating}
message("Assume the estimate of hot water kWh is true")

message("So estimated annual gas for heating = ", round(projAnnual_gas_kWh - annualHW,2), " kWh")

message("That's ", round((projAnnual_gas_kWh - annualHW)/6511,2), " times the EPC estimate of 6511 kWh... ")
```

Now switching to overall costs...

```{r totalCosts}
message("# Total projected energy")
message(round(projAnnual_gas_kWh + projAnnual_elec_kWh), " kWh")
message("This is ", round(100*((projAnnual_gas_kWh + projAnnual_elec_kWh)/(65*163))), " % of our EPC 'primary energy'")

message("#####")
message("# Total costs")
message("Monthly total £:", round((annualCost_gasCapped + annualCost_elecCapped)/12))

annualTotalcapped <- (annualCost_gasCapped + annualCost_elecCapped)

message("Annual total £:", round(annualTotalcapped,2))
```

If we then subtract the Energy Bill Support Scheme £400 this gives

```{r totalCostsAdjusted}
# subtract £400 Energy Bill Support Scheme
annualTotalcappedAdjusted <- annualTotalcapped - 400
message("Annual adjusted total £:", round(annualTotalcappedAdjusted,2))
message("Monthly adjusted total £:", round(annualTotalcappedAdjusted/12,2))
```

Note that octopus appear to be 'paying' this in [instalments of £67](https://octopus.energy/blog/government-support-with-energy-costs-this-winter/) by reducing the direct debit value.

> NB - this is a simple average across all days/months and takes no account of usage trends (see above). The octopus estimator is smarter than that :-)


# Annexes
## Data descriptions
### Electricity consumption

Use `skmir::skim()`to summarise.

```{r skimElecCons}
skimr::skim(elecCons_dt)
```

### Gas consumption

Use `skmir::skim()`to summarise.

```{r skimGasCons}
skimr::skim(gasCons_dt)
```


### NG-ESO data

Figure \@ref(fig:ngesoTile) shows the NG-ESO half-hourly carbon intensity over time for the data period as context. 

```{r ngesoTile, fig.cap="Half-hourly carbon intensity over time for the data period"}
ggplot2::ggplot(elecCons_dt, aes(x = dv_date, y = dv_hms, fill = CARBON_INTENSITY)) +
  geom_tile() +
  scale_fill_continuous(name = "Carbon intensity", low = "green", high = "red") +
  labs(x = "Date",
       y = "Time of day",
       caption = "Source: NG-ESO (https://data.nationalgrideso.com/carbon-intensity1/historic-generation-mix)")

```


# References

